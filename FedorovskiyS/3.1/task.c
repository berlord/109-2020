#include <stdio.h>
#include <math.h>
#include "prot.h"
double task(RFun f, double eps, double a, double b){//программа перебирает разбиения уменьшая разность, пока не найдет i удовлетворяющее неравенству на локальный минимум на множествее точек разбиения, и рассматривает новый отрезок с его соседями по разбиению на концах. Когда отрезок стал маленьким, исчем вершину параболы и значение от нее. если i не находится, выводим число заведомо больше чем значение на концах. для этого не требуется запоминать изначальные концы, т.к. нахождения одного i достаточно для гарантии нахождения минимума.
    double d = (b - a)/4;
    int i = 0, n = 4, flag = 0;
    while(d > 1e-7){
        while(i < n){
            if(f(a + i*d) > f(a + (i+1)*d)){
                break;
            }
            i++;
        }
        if(i == n){
            i = 0;
            d = d/2;
            n = n*2;
            continue;
        }
        i++;
        while(i < n){
            if(f(a + i*d) <= f(a + (i+1)*d)){
                break;
            }
            i++;
        }
        if(i == n){
            i = 0;
            d = d/2;
            n = n*2;
            continue;
        }
        a = a + (i - 1)*d;
        b = a + (i + 1)*d;
        if((flag == 1)&&(fabs(a-b) <= eps))
            break;
        i = 0;
        n = 4;
        d = d/2;
        flag = 1;
    }
    printf("%lf\n", (a+b)/2);
    if (flag == 0)
        return fabs(a) + fabs(b) + 1;
    return f( ((f(a)*(a + 3*b)) + (f(b)*(b + 3*a)) - (4*f((a+b)/2)*(a + b)))/(2*f(a) + 2*f(b) - 4*f((a+b)/2))/2 );
}
