/**
** Вариант 41.
** Имеется матрица A размера n на m, состоящая из слов (в качестве элементов матрицы).
** Необходимо найти строку k матрицы A, такую что обращенное слово R(W(k)) совпадает с некоторым из слов W(i), i=0,...,n-1.
** А затем "прибавить" её ко всем остальным строкам матрицы, исключая её саму.
** "Сложение" найденной строки k и строки p (для каждого q = 0, ..., m-1) происходит вычеркиванием из слова A_pq букв слова A_kq.
**
** Параметры:
** int argc: количество аргументов командной строки;
** char *argv[]: массив аргументов командной строки.
**
** В нулевом аргументе функция получает имя исполняемого файла, в первом - имя входного файла.
** Функция проверяет ошибки чтения входного и выходного файлов.
** Размеры марицы считываются из входного файла, также проверяется считывание.
** Выделяется памят под марицу, а затем используются функции поиска строки и сложения строк.
** Конечная матрица печатается в выходной файл.
**
** Возращаемое значение: в случае успеха - 0, иначе - (-1).
**
*/
#include "libs.h"


int main(int argc, char *argv[]) {
    int n, m;
    char **matrix;
    FILE *inp, *out;
    
    
    
    if ((inp = fopen(argv[1], "r")) == NULL) {
        printf("ERROR\n");
        return -1;
    }
    if ((out = fopen("result.txt", "w")) == NULL) {
        printf("ERROR\n");
        fclose(inp);
        return -1;
    }
    if(!fscanf(inp, "%d %d", &n, &m)){
        printf("ERROR::read error n, m");
        fclose(inp);
        fclose(out);
        return -1;
    } 
    matrix = malloc(n * m * sizeof(*matrix));
    read_string(inp);
    read_matrix(matrix, inp, n*m);
    sum(matrix, n, m, search(matrix, n, m));
    print_matrix(matrix, n, m, out);
    for(int i = 0; i < n*m; i++) {
        free(matrix[i]);
    }
    free(matrix);
    fclose(inp);
    fclose(out);
    return 0;
}
