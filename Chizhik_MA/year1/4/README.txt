Функции taylor_exp, taylor_sin, taylor_cos, taylor_log основаны на последовательном суммировании ряда Тейлора -
они не используют ни M_E, ни M_PI: заметим, что слагаемые рядов для элементарных функций могут быть 
сравнительно легко выражены рекуррентно, поэтому нет необходимости каждый раз возводить переменную в большую 
степень и делить на большой факториал, это повышало бы вероятность ошибки вычисления.
Однако для значений, далеких от нуля, непосредственное вычисление по формуле Тейлора может происходить 
либо очень долго, либо (в случае логарифма) - вообще не выполняться для x > 2. 
Поэтому были написаны функции effective_*:
1) e^x = e^([x] + {x}) = e^[x] * e^{x}, где [x] - целая часть числа, а {x} = x - [x] - дробная часть числа. 
Здесь мы используем M_E и возводим ее в целую степень, а дробную часть считаем суммированием ряда Тейлора
(используя taylor_exp) и перемножаем полученные результаты;
2) sin(-x) = -sin(x), sin(x) = sin(x - 2πn), где n - целое число. Поэтому делаем аргумент положительным
(вынося при необходимости аргумент за скобки), вычитаем 2π до тех пор, пока агрумент не станет <π 
(он может стать отрицательным, но нам важно, чтобы аргумент оказался в промежутке [-π; π] - 
там, где он лучше всего приближается рядом Тейлора), а затем считаем для полученного аргумента 
taylor_sin и в случае, если изначально x был отрицательным, умножаем результат на -1;
3) cos(-x) = cos(x), cos(x) = cos(x - 2πn), n - целое число. Проделываем аналогичные действия 
(только знак выносить не нужно в силу четности косинуса), к "улучшенному" аргументу (из промежутка [-π; π])
применяем taylor_cos и получаем ответ;
4) И, наконец, ln(x). Его можно приблизить, если 0 < x < 2 (при x < 0 логарифм не определен, 
при x > 2 ряд расходится). Поэтому отрицательные аргументы отсеиваем в силу ОДЗ логарифма, а в случае, 
если x > 1.65, начинаем его делить на корень из e (примерно 1.65) до тех пор, пока аргумент не станет 
<=1.65 (чтобы можно было приблизить рядом Тейлора достаточно быстро; каждое такое деление прибавляет 
1/2 к результату). Для полученного аргумента 0 < x <= 1.65 вызываем taylor_log.
